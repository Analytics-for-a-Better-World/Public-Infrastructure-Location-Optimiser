gpbp.layers
===========

.. py:module:: gpbp.layers


Classes
-------

.. autoapisummary::

   gpbp.layers.AdmArea


Module Contents
---------------

.. py:class:: AdmArea(country: str, level: int)

   .. py:attribute:: country


   .. py:attribute:: level


   .. py:attribute:: geometry
      :value: None



   .. py:attribute:: fac_gdf
      :value: None



   .. py:attribute:: pop_df
      :value: None



   .. py:attribute:: pot_fac_gdf
      :value: None



   .. py:attribute:: rwi_df
      :value: None



   .. py:attribute:: iso_gdf
      :value: None



   .. py:attribute:: road_network
      :value: None



   .. py:method:: _get_country_data() -> None


   .. py:method:: retrieve_adm_area_names() -> Union[List[str], numpy.typing.NDArray[numpy.str_]]

      Return all administrative areas

      :returns: * *list of strings*
                * *Names of administrative areas*



   .. py:method:: get_adm_area(adm_name: str) -> None

      Extract the geometry for a specific administrative area.
      :param adm_name: Administrative area name
      :type adm_name: string



   .. py:method:: get_facilities(method: str, tags: dict) -> None

      Retrieve facility locations specified by tags using a strategy
      defined by method

      :param method: Strategy alias. Currently supported options: 'osm'
      :type method: string
      :param tags: OSM tag dictionary
                   e.g. {'building':'hospital'} or {'amenity':['school', 'kindergarden']}
      :type tags: dictionary



   .. py:method:: get_population(method: str) -> None

      Retrieve geolocated statistical population count

      :param method: Strategy alias. Currently supported options: 'world_pop', 'fb_pop'
      :type method: string



   .. py:method:: get_road_network(network_type: str) -> None

      Retrieve open street map road network for a network_type
      and calculate road travel time

      :param network_type: The network type in terms of mode of transportation.
                           Valid inputs : 'driving', 'walking', 'cycling'
      :type network_type: string



   .. py:method:: get_rwi(method: str) -> None

      Retrieve geolocated relative wealth index

      :param method: Strategy alias. Currently supported options: 'fb_rwi'
      :type method: string



   .. py:method:: compute_potential_fac(spacing: float) -> None

      Compute potential facilities locations by generating evenly spaced points
      within the administrative area.

      :param spacing: Defines the distance between the points in coordinate units.
      :type spacing: float



   .. py:method:: prepare_optimization_data(distance_type: str, distance_values: list[int], mode_of_transport: str, strategy: str, mapbox_access_token: str = None, population_resolution: int = 5) -> tuple[numpy.ndarray[float], dict[pandas.DataFrame], dict[pandas.DataFrame]]

      Prepare input for the optimization model.
      Computes which households are served from existing and potential facility locations
      within the distance_values of the distance_type measure.

      :param distance_type: The measure of distance between points of interest.
                            Supported measures: 'length' (as in road length) and 'travel_time'.
      :type distance_type: string
      :param distance_values: Values of the distance measure. For length input is expected to be in meters,
                              for travel_time in minutes. For performance reasons values greater than 60 minutes
                              and 100000 meters are not accepted.
      :type distance_values: list-like of ints
      :param mode_of_transport: The mode of transportation assumed.
      :type mode_of_transport: string
      :param strategy: Strategy alias. Currently supported options: 'osm', 'mapbox'.
      :type strategy: string
      :param mapbox_access_token: If mapbox strategy selected the access token to be used for the mapbox api.
      :type mapbox_access_token: string
      :param population_resoltion: The resolution of the geolocation coordinates of population households
                                   in terms of number of decimal digits. Value should be in the range of (1,6).
                                   The higher the value the more fine-grained the resolution.
      :type population_resoltion: int

      :returns: * **pop_count** (*array of floats*) -- The population count of households.
                * **current** (*dictionary of DataFrames*) -- They key of the dictionary is the distance_type and the value is a DataFrame
                  using as index the current facilities ids and containing columns of the form ID_{distance_value}
                  for each of the distance values where each element contains a list of household ids
                  which are served from the index facility within the distance_value.
                * **potential** (*dictionary of DataFrames*) -- Same as current but for the potential location of facilities.



